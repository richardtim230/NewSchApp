<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Official Exam — In Session | ExamGuard</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link href="https://fonts.googleapis.com/css?family=Inter:400,600,700&display=swap" rel="stylesheet">
  <link rel="icon" href="../logo.png">

  <style>
    :root{
      --bg-0:#f6f8ff; --bg-1:#eef2ff;
      --accent:#3b82f6; --accent-2:#6366f1; --muted:#6b7280;
      --card-bg:#ffffff; --sidebar-w:86vw; --desk-sidebar-w:300px;
      --danger:#ef4444; --success:#10b981;
      --max-image-h: 42vh;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial;background:linear-gradient(180deg,var(--bg-0),var(--bg-1));-webkit-font-smoothing:antialiased;color:#0b2a44}
    a{color:inherit;text-decoration:none}

    /* Top bar */
    .topbar {
      position:sticky; top:0; z-index:120; display:flex;align-items:center;justify-content:space-between;padding:12px 16px;background:rgba(255,255,255,0.92);border-bottom:1px solid rgba(11,42,60,0.06);
    }
    .brand { display:flex; gap:12px; align-items:center; }
    .brand img { width:42px;height:42px;border-radius:8px; }
    .page-title { font-weight:900; font-size:1rem; color:var(--accent-2); }

    .main-wrap { padding:18px; max-width:1200px; margin:18px auto; }

    /* Layout: exam area + side panel (question map, timer) */
    .session { display:grid; grid-template-columns: 1fr 320px; gap:16px; align-items:start; }
    @media (max-width:980px) { .session { grid-template-columns: 1fr 320px; } }
    @media (max-width:780px) { .session { grid-template-columns: 1fr; } }

    .card { background:var(--card-bg); border-radius:12px; padding:14px; box-shadow: 0 8px 20px rgba(11,42,60,0.04); border:1px solid rgba(11,42,60,0.03); }

    /* Question area */
    .question-head { display:flex; justify-content:space-between; gap:12px; align-items:center; flex-wrap:wrap; }
    .exam-meta { font-weight:800; font-size:1.05rem; }
    .muted-small { color:var(--muted); font-size:0.9rem; }

    .question-body { margin-top:12px; min-height:220px; }
    .question-text { font-weight:800; font-size:1.05rem; line-height:1.45; margin-bottom:10px; }
    .choices { margin-top:8px; display:flex; flex-direction:column; gap:8px; }
    .choice { padding:10px 12px; border-radius:10px; border:1px solid #eef3ff; background:#fff; cursor:pointer; display:flex; gap:12px; align-items:center; text-align:left; }
    .choice .letter { width:36px; text-align:center; font-weight:900; border-radius:8px; background:#f3f6fb; color:var(--muted); padding:6px; }
    .choice.selected { background:linear-gradient(90deg,var(--accent),var(--accent-2)); color:#fff; border-color:rgba(59,130,246,0.18); }
    .choice.multi .letter { background:transparent; color:var(--muted); }

    /* in-question image */
    .q-image-wrap { margin-top:12px; display:flex; justify-content:center; }
    .q-image { max-width:100%; max-height:var(--max-image-h); object-fit:contain; border-radius:8px; box-shadow:0 8px 20px rgba(11,42,60,0.06); cursor:zoom-in; }
    .image-caption { font-size:0.85rem; color:var(--muted); margin-top:6px; text-align:center; }

    /* image modal */
    .img-modal { position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:1400; background:rgba(2,6,23,0.85); padding:16px; }
    .img-modal.active { display:flex; }
    .img-modal img { max-width:98vw; max-height:96vh; border-radius:8px; }

    /* controls */
    .controls { margin-top:14px; display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .btn { padding:10px 14px; border-radius:10px; border:none; cursor:pointer; background:linear-gradient(90deg,var(--accent),var(--accent-2)); color:#fff; font-weight:800; }
    .btn.ghost { background:transparent; color:var(--accent-2); border:1px solid rgba(59,130,246,0.08); }
    .btn.warn { background:linear-gradient(90deg,#f97316,#f59e0b); }
    .btn.small { padding:6px 10px; font-size:0.95rem; }

    /* side panel */
    .side { display:flex; flex-direction:column; gap:12px; position:sticky; top:92px; align-self:start; }
    .timer { font-weight:900; font-size:1.1rem; background:#fff; padding:10px; border-radius:10px; border:1px solid #eef3ff; text-align:center; }
    .qmap { display:grid; grid-template-columns:repeat(5,1fr); gap:8px; margin-top:10px; }
    .qbtn { padding:8px; border-radius:8px; border:1px solid #eef3ff; background:#fff; cursor:pointer; font-weight:800; text-align:center; }
    .qbtn.answered { background:linear-gradient(90deg,var(--accent),var(--accent-2)); color:#fff; }
    .qbtn.flagged { border:2px solid var(--danger); }

    /* progress bar */
    .progress-bar { width:100%; background:#eef3ff; height:8px; border-radius:999px; overflow:hidden; margin-top:10px; }
    .progress-bar > i { display:block; height:100%; background:linear-gradient(90deg,var(--accent),var(--accent-2)); width:0%; transition:width .28s ease; }

    /* integrity & status */
    .status { display:flex; gap:8px; align-items:center; margin-top:8px; }
    .status .pill { padding:6px 8px; border-radius:999px; background:#f3f6fb; font-weight:700; color:var(--muted); }

    /* login overlay inside page */
    .login-overlay { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; z-index:140; background:rgba(2,6,23,0.6); }
    .login-card { width:560px; max-width:92vw; border-radius:12px; background:#fff; padding:18px; }
    .form-row { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }
    input[type="text"], input[type="password"], input[type="number"], textarea { padding:10px; border-radius:8px; border:1px solid #e6e9ef; width:100%; }

    /* lock overlay when submitted */
    .locked { opacity:0.6; pointer-events:none; user-select:none; }

    /* autosave indicator */
    .save-indicator { font-size:0.9rem; color:var(--muted); margin-left:6px; }

    /* accessibility focus */
    :focus { outline:3px solid rgba(99,102,241,0.18); outline-offset:2px; border-radius:6px }

    /* small screens */
    @media (max-width:520px) {
      .choice .letter { width:28px; font-weight:800; padding:4px; }
      .qmap { grid-template-columns:repeat(4,1fr); }
    }
  </style>
</head>
<body>
  <div class="topbar" role="banner">
    <div class="brand" aria-hidden="false">
      <img src="../logo.png" alt="School logo">
      <div>
        <div class="page-title">Official Examination — Secure Session</div>
        <div class="muted-small" id="examSessionMeta">Central Exam</div>
      </div>
    </div>

    <div style="display:flex;gap:12px;align-items:center">
      <div class="muted-small" id="connectionStatus">Preparing...</div>
      <div class="save-indicator" id="saveIndicator">Not saved</div>
    </div>
  </div>

  <main class="main-wrap" role="main">
    <!-- Login overlay shown until student verifies identity for this session -->
    <div id="loginOverlay" class="login-overlay" role="dialog" aria-modal="true" aria-labelledby="loginTitle">
      <div class="login-card card" role="document">
        <h2 id="loginTitle">Exam authentication</h2>
        <p class="muted-small">Enter your admission number and exam code to begin. Your session will be monitored.</p>

        <form id="authForm" style="margin-top:12px">
          <div class="form-row">
            <label style="flex:1">
              Admission number
              <input id="admNumber" type="text" autocomplete="off" required aria-required="true" />
            </label>
            <label style="width:160px">
              Exam code
              <input id="examCode" type="password" autocomplete="off" required aria-required="true" />
            </label>
          </div>

          <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
            <button class="btn ghost" type="button" id="authCancel">Cancel</button>
            <button class="btn" type="submit" id="authSubmit">Verify & Join</button>
          </div>

          <div class="muted-note" id="authHint">You must verify before starting. Your camera & focus may be monitored (institution policy).</div>
        </form>
      </div>
    </div>

    <!-- Image modal for zoomed images -->
    <div id="imgModal" class="img-modal" role="dialog" aria-hidden="true" aria-modal="true">
      <img id="imgModalImg" src="" alt="Question image" />
    </div>

    <!-- Main session UI -->
    <div id="sessionArea" class="session" aria-live="polite" style="display:none">
      <section class="card" id="questionCard" aria-labelledby="qHead">
        <div class="question-head" id="qHead">
          <div>
            <div class="exam-meta" id="examTitle">—</div>
            <div class="muted-small" id="examInfo">Class / Subject • Exam</div>
            <div class="progress-bar" title="Exam progress"><i id="progressFill" style="width:0%"></i></div>
          </div>

          <div style="display:flex;gap:10px;align-items:center">
            <div class="timer" id="timer">00:00</div>
            <button class="btn ghost" id="fullscreenBtn">Full screen</button>
            <div id="studentSnapshot" style="text-align:right">
              <div class="muted-small">Student: <strong id="studentName">—</strong></div>
              <div class="muted-small" id="studentClass">—</div>
            </div>
          </div>
        </div>

        <div class="question-body" id="questionBody">
          <div id="loadingPlaceholder" class="muted-small">Waiting for questions...</div>
        </div>

        <div class="controls" id="sessionControls">
          <div>
            <button class="btn ghost small" id="prevBtn" aria-label="Previous question">← Previous</button>
            <button class="btn ghost small" id="nextBtn" aria-label="Next question">Next →</button>
            <button class="btn ghost small" id="flagBtn" aria-pressed="false">Flag</button>
            <button class="btn ghost small" id="reviewBtn">Review</button>
          </div>

          <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
            <button class="btn" id="saveBtn">Save answer</button>
            <button class="btn warn" id="submitBtn">Submit exam</button>
          </div>
        </div>

        <div id="integrityBox" style="margin-top:14px" class="muted-small">
          <div>Focus warnings: <strong id="focusWarnings">0</strong></div>
          <div class="muted-small">Do not switch windows or open other applications. Window switches are tracked.</div>
        </div>
      </section>

      <aside class="side">
        <div class="card">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div style="font-weight:800">Session</div>
            <div class="muted-small" id="sessionId">—</div>
          </div>

          <div style="margin-top:10px" id="sessionMeta">
            <div class="muted-small">Exam: <strong id="examShort">—</strong></div>
            <div class="muted-small">Time remaining: <strong id="timerSmall">00:00</strong></div>
          </div>

          <div style="margin-top:12px">
            <div style="font-weight:800">Question map</div>
            <div class="qmap" id="qMap" role="navigation" aria-label="Question map" tabindex="0"></div>
          </div>

          <div style="margin-top:12px">
            <div style="display:flex;justify-content:space-between;align-items:center">
              <div style="font-weight:800">Progress</div>
              <div class="muted-small" id="progressMeta">0 / 0</div>
            </div>

            <div style="margin-top:8px" class="status">
              <div class="pill" id="answeredCount">Answered: 0</div>
              <div class="pill" id="flaggedCount">Flagged: 0</div>
            </div>
          </div>
        </div>

        <div class="card">
          <div style="font-weight:800">Rules & Help</div>
          <ul class="muted-small" style="margin-top:8px">
            <li>Do not refresh or close your browser during the exam.</li>
            <li>Switching windows may be recorded and may lead to sanctions.</li>
            <li>Use Save frequently — answers are auto-saved periodically.</li>
          </ul>
          <div style="margin-top:12px;display:flex;gap:8px">
            <button class="btn ghost" id="helpBtn">Help</button>
            <button class="btn" id="reportBtn">Report issue</button>
          </div>
        </div>
      </aside>
    </div>

    <!-- Submission modal -->
    <div id="submitModal" class="login-overlay" style="display:none" role="dialog" aria-modal="true">
      <div class="login-card card">
        <h3>Confirm submission</h3>
        <p class="muted-small">You are about to submit your answers. This action cannot be undone. Make sure you saved your answers.</p>
        <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
          <button class="btn ghost" id="cancelSubmit">Cancel</button>
          <button class="btn warn" id="confirmSubmit">Submit now</button>
        </div>
      </div>
    </div>

    <!-- Result / End modal -->
    <div id="endModal" class="login-overlay" style="display:none" role="dialog" aria-modal="true">
      <div class="login-card card">
        <h3>Exam submitted</h3>
        <p class="muted-small" id="endMessage">Thank you — your answers have been recorded.</p>
        <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
          <button class="btn" id="endOk">Close</button>
        </div>
      </div>
    </div>

  </main>

  <script>
    (function () {
      // CONFIG
      const API_BASE = 'https://examguide.onrender.com/api';
      const AUTO_SAVE_INTERVAL = 7000; // ms
      const FOCUS_WARNING_LIMIT = 3;
      const TOKEN = localStorage.getItem('eg_token') || null;

      // STATE
      const session = {
        sessionId: null,
        examId: null,
        student: null,
        questions: [], // {id, q, choices, type:'mcq'|'multi'|'text', imageUrl?, imageCaption?, timeLimitSec?}
        currentIndex: 0,
        answers: {}, // qid -> index or [indices] or text
        flagged: new Set(),
        durationSec: 0,
        remaining: 0,
        focusWarnings: 0,
        isSubmitted: false,
        lastSavedAt: null
      };

      let autoSaveTimer = null, countdownT = null;

      // DOM
      const loginOverlay = document.getElementById('loginOverlay');
      const authForm = document.getElementById('authForm');
      const admNumberEl = document.getElementById('admNumber');
      const examCodeEl = document.getElementById('examCode');
      const authCancel = document.getElementById('authCancel');

      const sessionArea = document.getElementById('sessionArea');
      const examTitle = document.getElementById('examTitle');
      const examInfo = document.getElementById('examInfo');
      const timerEl = document.getElementById('timer');
      const timerSmall = document.getElementById('timerSmall');
      const questionBody = document.getElementById('questionBody');
      const prevBtn = document.getElementById('prevBtn');
      const nextBtn = document.getElementById('nextBtn');
      const flagBtn = document.getElementById('flagBtn');
      const saveBtn = document.getElementById('saveBtn');
      const submitBtn = document.getElementById('submitBtn');
      const fullscreenBtn = document.getElementById('fullscreenBtn');
      const qMap = document.getElementById('qMap');
      const answeredCountEl = document.getElementById('answeredCount');
      const flaggedCountEl = document.getElementById('flaggedCount');
      const progressMeta = document.getElementById('progressMeta');
      const progressFill = document.getElementById('progressFill');
      const connectionStatus = document.getElementById('connectionStatus');
      const saveIndicator = document.getElementById('saveIndicator');

      const sessionIdEl = document.getElementById('sessionId');
      const studentNameEl = document.getElementById('studentName');
      const studentClassEl = document.getElementById('studentClass');
      const examShort = document.getElementById('examShort');

      const imgModal = document.getElementById('imgModal');
      const imgModalImg = document.getElementById('imgModalImg');

      const submitModal = document.getElementById('submitModal');
      const cancelSubmit = document.getElementById('cancelSubmit');
      const confirmSubmit = document.getElementById('confirmSubmit');

      const endModal = document.getElementById('endModal');
      const endMessage = document.getElementById('endMessage');
      const endOk = document.getElementById('endOk');

      // UTILITIES
      function authHeaders(contentType = 'application/json') {
        const h = {};
        if (contentType) h['Content-Type'] = contentType;
        if (TOKEN) h['Authorization'] = 'Bearer ' + TOKEN;
        return h;
      }
      function escapeHtml(s) { return String(s || '').replace(/[&<>"']/g, function (m) { return ({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' })[m]; }); }
      function delay(ms){ return new Promise(r=>setTimeout(r,ms)); }

      // Persist/load local save
      function localKey() {
        return 'eg_exam_' + (session.sessionId || session.examId || 'unknown');
      }
      function persistLocal() {
        try {
          const payload = {
            sessionId: session.sessionId, examId: session.examId, student: session.student,
            answers: session.answers, flagged: Array.from(session.flagged), currentIndex: session.currentIndex, remaining: session.remaining
          };
          localStorage.setItem(localKey(), JSON.stringify(payload));
          session.lastSavedAt = Date.now();
          updateSaveIndicator('Saved locally');
        } catch (e) { console.warn('persist failed', e); updateSaveIndicator('Save failed'); }
      }
      function loadLocal() {
        try {
          const raw = localStorage.getItem(localKey());
          if (!raw) return null;
          return JSON.parse(raw);
        } catch { return null; }
      }

      // Render question (supports images and types)
      function renderQuestion(index) {
        if (!session.questions || !session.questions.length) {
          questionBody.innerHTML = '<div class="muted-small">No questions available.</div>';
          return;
        }
        session.currentIndex = Math.max(0, Math.min(index, session.questions.length - 1));
        const q = session.questions[session.currentIndex];
        const qnum = session.currentIndex + 1;

        const wrapper = document.createElement('div');

        // question header: number and optional per-question timer
        let headerHTML = `<div class="question-text">Q${qnum}. ${escapeHtml(q.q)}</div>`;
        wrapper.innerHTML = headerHTML;

        // optional image
        if (q.imageUrl) {
          const imgWrap = document.createElement('div');
          imgWrap.className = 'q-image-wrap';
          const img = document.createElement('img');
          img.className = 'q-image';
          img.src = q.imageUrl;
          img.alt = q.imageCaption || 'Question image';
          img.loading = 'lazy';
          img.addEventListener('click', ()=> openImageModal(q.imageUrl));
          imgWrap.appendChild(img);
          if (q.imageCaption) {
            const cap = document.createElement('div');
            cap.className = 'image-caption';
            cap.textContent = q.imageCaption;
            imgWrap.appendChild(cap);
          }
          wrapper.appendChild(imgWrap);
        }

        // choices / input area
        const choicesWrap = document.createElement('div');
        choicesWrap.className = 'choices';
        if (q.type === 'text' || q.type === 'short') {
          const ta = document.createElement('textarea');
          ta.rows = 4;
          ta.style.width = '100%';
          ta.placeholder = 'Type your answer here...';
          ta.value = session.answers[q.id] || '';
          ta.addEventListener('input', (e) => {
            session.answers[q.id] = e.target.value;
            persistLocal(); renderQMap(); updateProgress();
          });
          choicesWrap.appendChild(ta);
        } else {
          const isMulti = q.type === 'multi' || q.allowMultiple;
          q.choices.forEach((c, idx) => {
            const btn = document.createElement('button');
            btn.className = 'choice' + (isMulti ? ' multi' : '');
            btn.type = 'button';
            btn.dataset.idx = idx;
            const selected = isMulti ? (Array.isArray(session.answers[q.id]) && session.answers[q.id].includes(idx)) : (session.answers[q.id] === idx);
            if (selected) btn.classList.add('selected');
            btn.innerHTML = `<div class="letter">${isMulti ? (selected ? '✓' : String.fromCharCode(65 + idx)) : String.fromCharCode(65 + idx)}</div><div style="flex:1;text-align:left">${escapeHtml(c)}</div>`;
            btn.addEventListener('click', () => {
              if (isMulti) {
                let arr = Array.isArray(session.answers[q.id]) ? session.answers[q.id].slice() : [];
                const pos = arr.indexOf(idx);
                if (pos === -1) arr.push(idx); else arr.splice(pos,1);
                session.answers[q.id] = arr;
              } else {
                session.answers[q.id] = idx;
              }
              renderQuestion(session.currentIndex);
              renderQMap();
              persistLocal();
            });
            choicesWrap.appendChild(btn);
          });
        }

        wrapper.appendChild(choicesWrap);
        questionBody.innerHTML = '';
        questionBody.appendChild(wrapper);

        // update button states & UI
        prevBtn.disabled = session.currentIndex === 0;
        nextBtn.disabled = session.currentIndex === session.questions.length - 1;
        flagBtn.setAttribute('aria-pressed', session.flagged.has(q.id) ? 'true' : 'false');
        flagBtn.textContent = session.flagged.has(q.id) ? 'Flagged' : 'Flag';

        // progress and map updates
        updateProgress();
      }

      // Render question map
      function renderQMap() {
        qMap.innerHTML = '';
        session.questions.forEach((q, i) => {
          const btn = document.createElement('button');
          btn.className = 'qbtn' + (session.answers[q.id] !== undefined && session.answers[q.id] !== null && (!(Array.isArray(session.answers[q.id]) && session.answers[q.id].length === 0)) ? ' answered' : '') + (session.flagged.has(q.id) ? ' flagged' : '');
          btn.textContent = i + 1;
          btn.dataset.i = i;
          btn.addEventListener('click', ()=> {
            renderQuestion(i);
          });
          qMap.appendChild(btn);
        });
      }

      function updateProgress() {
        const answered = session.questions.reduce((s,q)=> {
          const a = session.answers[q.id];
          if (a === undefined || a === null) return s;
          if (Array.isArray(a)) return s + (a.length ? 1 : 0);
          if (typeof a === 'string') return s + (a.trim() ? 1 : 0);
          return s + 1;
        }, 0);
        const flagged = Array.from(session.flagged).length;
        answeredCountEl.textContent = `Answered: ${answered}`;
        flaggedCountEl.textContent = `Flagged: ${flagged}`;
        progressMeta.textContent = `${answered} / ${session.questions.length}`;
        progressFill.style.width = ((answered / Math.max(1, session.questions.length)) * 100) + '%';
      }

      // Image modal
      function openImageModal(src) {
        imgModalImg.src = src;
        imgModal.classList.add('active');
        imgModal.setAttribute('aria-hidden', 'false');
      }
      imgModal.addEventListener('click', ()=> {
        imgModal.classList.remove('active');
        imgModal.setAttribute('aria-hidden', 'true');
        imgModalImg.src = '';
      });

      // Controls
      prevBtn.addEventListener('click', ()=> renderQuestion(session.currentIndex - 1));
      nextBtn.addEventListener('click', ()=> renderQuestion(session.currentIndex + 1));
      flagBtn.addEventListener('click', ()=> {
        const q = session.questions[session.currentIndex];
        if (!q) return;
        if (session.flagged.has(q.id)) session.flagged.delete(q.id); else session.flagged.add(q.id);
        renderQuestion(session.currentIndex);
        renderQMap();
        persistLocal();
      });

      saveBtn.addEventListener('click', ()=> {
        persistLocal();
        updateSaveIndicator('Saved');
      });

      // Autosave (persist locally and attempt server save)
      function startAutoSave() {
        stopAutoSave();
        autoSaveTimer = setInterval(async ()=> {
          persistLocal();
          await tryServerSave(false);
        }, AUTO_SAVE_INTERVAL);
      }
      function stopAutoSave() {
        if (autoSaveTimer) { clearInterval(autoSaveTimer); autoSaveTimer = null; }
      }

      async function tryServerSave(showToast = false) {
        if (!session.sessionId && !session.examId) return;
        const payload = {
          sessionId: session.sessionId, examId: session.examId, studentId: session.student && session.student.id,
          answers: session.answers, flagged: Array.from(session.flagged), currentIndex: session.currentIndex, remaining: session.remaining
        };
        try {
          await fetch(`${API_BASE}/exams/session/save`, { method:'POST', headers: authHeaders('application/json'), body: JSON.stringify(payload) });
          session.lastSavedAt = Date.now();
          updateSaveIndicator('Saved to server');
        } catch (err) {
          updateSaveIndicator('Saved locally (offline)');
        }
      }

      function updateSaveIndicator(text) {
        saveIndicator.textContent = text || 'Saved';
      }

      // Timer
      function startTimer() {
        if (countdownT) clearInterval(countdownT);
        updateTimerDisplays();
        countdownT = setInterval(()=> {
          if (session.remaining > 0) {
            session.remaining--;
            updateTimerDisplays();
            if (session.remaining % 30 === 0) persistLocal();
          } else {
            clearInterval(countdownT);
            autoSubmit('Time expired');
          }
        }, 1000);
      }
      function updateTimerDisplays() {
        const m = String(Math.floor(session.remaining / 60)).padStart(2,'0');
        const s = String(session.remaining % 60).padStart(2,'0');
        timerEl.textContent = `${m}:${s}`;
        timerSmall.textContent = `${m}:${s}`;
        const pct = session.durationSec ? (session.remaining / session.durationSec) : 0;
        if (pct < 0.1) timerEl.style.color = 'var(--danger)';
        else if (pct < 0.25) timerEl.style.color = '#d97706';
        else timerEl.style.color = '#0b2a44';
      }

      // Fullscreen
      fullscreenBtn.addEventListener('click', ()=> {
        if (!document.fullscreenElement) document.documentElement.requestFullscreen?.();
        else document.exitFullscreen?.();
      });

      // Submission
      submitBtn.addEventListener('click', ()=> submitModal.style.display = 'flex');
      cancelSubmit.addEventListener('click', ()=> submitModal.style.display = 'none');
      confirmSubmit.addEventListener('click', async ()=> {
        submitModal.style.display = 'none';
        await doSubmit('User confirmed submit');
      });

      async function doSubmit(reason) {
        if (session.isSubmitted) return;
        stopAutoSave(); if (countdownT) clearInterval(countdownT);
        const payload = {
          sessionId: session.sessionId, examId: session.examId, studentId: session.student && session.student.id,
          answers: session.answers, flagged: Array.from(session.flagged), reason, timestamp: new Date().toISOString()
        };
        try {
          const res = await fetch(`${API_BASE}/exams/session/submit`, { method:'POST', headers: authHeaders('application/json'), body: JSON.stringify(payload) });
          if (!res.ok) throw new Error('Server submission failed');
          const data = await res.json();
          session.isSubmitted = true;
          document.getElementById('questionCard').classList.add('locked');
          endMessage.innerHTML = `Your answers were submitted. Trace: <strong>${data.trace || '—'}</strong>. Score will be available after grading.`;
          endModal.style.display = 'flex';
        } catch (err) {
          console.error('submit failed', err);
          // fallback: save locally and inform user
          persistLocal();
          alert('Submission failed; answers saved locally and will be re-sent when connection is restored.');
        }
      }

      endOk.addEventListener('click', ()=> {
        endModal.style.display = 'none';
        window.location.href = '/';
      });

      // Visibility / focus tracking
      function setupVisibilityTracking() {
        document.addEventListener('visibilitychange', ()=> {
          if (document.hidden) {
            session.focusWarnings++;
            document.getElementById('focusWarnings').textContent = session.focusWarnings;
            session.infractions = session.infractions || [];
            session.infractions.push({ type:'hidden', at: new Date().toISOString() });
            if (session.focusWarnings >= FOCUS_WARNING_LIMIT) alert('Multiple focus switches detected. This will be recorded.');
          } else {
            tryServerSave(false);
          }
        });
        window.addEventListener('blur', ()=> {
          session.focusWarnings++;
          document.getElementById('focusWarnings').textContent = session.focusWarnings;
        });
      }

      // Keyboard shortcuts
      document.addEventListener('keydown', (e)=> {
        if (loginOverlay.style.display !== 'none') return; // not auth'd yet
        if (session.isSubmitted) return;
        if (e.key === 'ArrowRight') renderQuestion(session.currentIndex + 1);
        if (e.key === 'ArrowLeft') renderQuestion(session.currentIndex - 1);
        if (/^[1-9]$/.test(e.key)) {
          const idx = parseInt(e.key,10) - 1;
          const q = session.questions[session.currentIndex];
          if (!q || !q.choices) return;
          if (q.type === 'multi' || q.allowMultiple) {
            const arr = Array.isArray(session.answers[q.id]) ? session.answers[q.id].slice() : [];
            const pos = arr.indexOf(idx);
            if (pos === -1) arr.push(idx); else arr.splice(pos,1);
            session.answers[q.id] = arr;
          } else {
            session.answers[q.id] = idx;
          }
          renderQuestion(session.currentIndex);
          renderQMap();
          persistLocal();
        }
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's') {
          e.preventDefault(); persistLocal(); tryServerSave(true);
        }
      });

      // Helper: try to fetch exam session and questions from backend after verifying
      async function startSessionVerify(adm, code, examId) {
        // We'll POST to /exams/:examId/join or /exams/join
        const payload = { admission: adm, code, examId };
        const candidates = [
          `${API_BASE}/exams/${encodeURIComponent(examId)}/join`,
          `${API_BASE}/exams/join`,
          `${API_BASE}/session/join`
        ];
        for (const url of candidates) {
          try {
            const res = await fetch(url, { method:'POST', headers: authHeaders('application/json'), body: JSON.stringify(payload) });
            if (!res.ok) continue;
            const data = await res.json();
            // expect shape: { ok:true, student:{}, sessionId, exam:{id,title,subject,durationMinutes}, questions: [...] }
            return data;
          } catch (err) {
            console.warn('join candidate failed', url, err);
          }
        }
        return null;
      }

      // AUTH FORM - try backend verification, fallback to demo when query param demo=1
      authForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const adm = admNumberEl.value.trim();
        const code = examCodeEl.value.trim();
        const examId = new URLSearchParams(window.location.search).get('exam') || null;
        if (!adm || !code) { document.getElementById('authHint').textContent = 'Admission number and exam code are required.'; return; }
        document.getElementById('authHint').textContent = 'Verifying...';
        try {
          const data = await startSessionVerify(adm, code, examId);
          if (!data) {
            // fallback demo if ?demo=1
            const p = new URLSearchParams(window.location.search);
            if (p.get('demo') === '1') {
              // DEMO: minimal session using serverless mock (kept only if explicitly requested)
              await delay(400);
              const demoExam = { id: examId || 'DEMO-EXAM', title: 'Demo Exam', subject: 'General', durationMinutes: 30 };
              session.student = { id: adm, name: 'Demo Student', class: 'SS2' };
              session.sessionId = 'S-DEMO-' + Math.random().toString(36).slice(2,8).toUpperCase();
              session.examId = demoExam.id;
              session.questions = demoQuestionsForDemo(); // small demo generator
              session.durationSec = demoExam.durationMinutes * 60;
              session.remaining = session.durationSec;
              document.getElementById('authHint').textContent = '';
            } else {
              document.getElementById('authHint').textContent = 'Verification failed or server unreachable.';
              return;
            }
          } else {
            if (!data.ok) { document.getElementById('authHint').textContent = data.message || 'Verification failed'; return; }
            // normalize server response
            session.student = data.student || data.user || session.student;
            session.sessionId = data.sessionId || data.session || ('S-' + Math.random().toString(36).slice(2,10).toUpperCase());
            session.examId = (data.exam && (data.exam.id || data.exam._id)) || data.examId || examId;
            session.questions = Array.isArray(data.questions) ? data.questions : (Array.isArray(data.items) ? data.items : []);
            // map duration
            session.durationSec = (data.exam && (Number(data.exam.durationMinutes) || 0) * 60) || (Number(data.durationMinutes) || 0) * 60 || (30 * 60);
            session.remaining = Number(data.remaining) || session.durationSec;
          }

          // apply UI
          loginOverlay.style.display = 'none';
          sessionArea.style.display = '';
          examTitle.textContent = (data && data.exam && data.exam.title) || ('Exam ' + (session.examId || ''));
          examInfo.textContent = (data && data.exam && (data.exam.subject || '')) || '';
          examShort.textContent = (data && data.exam && data.exam.title) || '';
          sessionIdEl.textContent = session.sessionId || '';
          studentNameEl.textContent = session.student && session.student.name || session.student && session.student.id || 'Student';
          studentClassEl.textContent = session.student && (session.student.class || session.student.program) || '';
          // try restore local save
          const local = loadLocal();
          if (local && local.answers) {
            // merge carefully: prefer local answers
            session.answers = Object.assign({}, session.answers || {}, local.answers);
            if (Array.isArray(local.flagged)) local.flagged.forEach(f => session.flagged.add(f));
            session.currentIndex = local.currentIndex || session.currentIndex;
            session.remaining = local.remaining || session.remaining;
          } else session.answers = {};
          renderQMap();
          renderQuestion(session.currentIndex);
          startAutoSave(); startTimer(); setupVisibilityTracking();
          tryServerSave(false);
          document.getElementById('connectionStatus').textContent = navigator.onLine ? 'Online' : 'Offline';
        } catch (err) {
          console.error(err);
          document.getElementById('authHint').textContent = 'Network or server error during verification.';
        }
      });

      authCancel.addEventListener('click', ()=> {
        if (confirm('Cancel and return to the main page?')) window.location.href = '/';
      });

      // Demo question generator (only used explicitly when ?demo=1)
      function demoQuestionsForDemo() {
        const arr = [];
        for (let i=1;i<=20;i++){
          arr.push({
            id: 'Q' + i,
            q: `Demo question ${i}. Select the best option.`,
            choices: ['Alpha','Beta','Gamma','Delta'],
            type: 'mcq',
            imageUrl: (i % 5 === 0) ? 'https://placekitten.com/800/400' : undefined,
            imageCaption: (i % 5 === 0) ? 'Illustration' : undefined
          });
        }
        return arr;
      }

      // server save on unload
      window.addEventListener('beforeunload', (e) => {
        persistLocal();
      });

      // network status
      window.addEventListener('online', () => {
        document.getElementById('connectionStatus').textContent = 'Online';
        tryServerSave(false);
      });
      window.addEventListener('offline', () => {
        document.getElementById('connectionStatus').textContent = 'Offline — answers saved locally';
      });

      // helper to set active tab if needed (used by other pages)
      function setActiveTabIfNeeded(name) {
        const current = (location.hash || '').replace('#', '') || '';
        if (current !== name) {
          history.replaceState(null, '', '#' + name);
          window.dispatchEvent(new Event('hashchange'));
        }
      }

      // Initial: if demo=1 then prefill? we rely on explicit user action
      (function init() {
        // nothing to do: waiting for user verification
      })();

      // Expose minimal API for debugging
      window._eg_official_session = session;

    })();
  </script>
</body>
</html>
