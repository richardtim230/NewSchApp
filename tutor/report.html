<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=0.8">
  <title>OAU ExamGuard CBT | Exam Report</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Add jsPDF & html2canvas for PDF generation -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />

  <!-- MathJax v3: render LaTeX inside questions, options and explanations -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['\\(', '\\)'], ['$', '$']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
        packages: {'[+]': ['noerrors']}
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
      },
      svg: { fontCache: 'global' }
    };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" id="MathJax-script" async></script>

  <style>
    .answer-pill { display:inline-block; border-radius:9999px; padding:0.25em 0.8em; font-weight:700;}
    .answer-user    { background: #dbeafe; color: #1e3a8a;}
    .answer-correct { background: #bbf7d0; color: #166534;}
    .answer-wrong   { background: #fee2e2; color: #991b1b;}
    .explanation { background: #f9fafb; border-left: 4px solid #38bdf8; padding: 1em 1.3em; border-radius:0.5em; font-size: 1.02rem;}
    .qcard { background: #fff; border-radius: 1.2em; box-shadow: 0 3px 18px #039be514; margin-bottom: 2.5rem; padding: 2rem 1.5rem;}
    .qcard.correct { border: 2px solid #16a34a; }
    .qcard.incorrect { border: 2px solid #dc2626; }
  </style>
</head>
<body class="bg-gradient-to-br from-blue-50 to-indigo-100 min-h-screen py-10 px-2">
  <div class="max-w-3xl mx-auto bg-white rounded-3xl shadow-xl p-8" id="report-main">
    <div class="flex flex-col sm:flex-row items-center sm:justify-between">
      <div>
        <h1 class="text-3xl font-black text-blue-800 flex items-center mb-1">
          <i class="fa fa-award text-yellow-400 mr-2"></i> Exam Report
        </h1>
        <div class="text-base text-blue-600 font-semibold mb-3" id="subject"></div>
      </div>
      <div>
        <button onclick="location.href='exam-in-session'" class="py-1 px-4 rounded text-xs bg-blue-200 text-blue-800 font-bold hover:bg-blue-300 mb-2 sm:mb-0">Retake Exam</button>
        <button id="download-pdf-btn" class="py-1 px-4 rounded text-xs bg-green-200 text-green-800 font-bold hover:bg-green-300 mb-2 sm:mb-0 ml-2">
          <i class="fa fa-download mr-1"></i>Download PDF
        </button>
      </div>
    </div>
    <div class="border-b border-gray-200 mb-6 pb-4">
      <span class="mr-6 font-bold"><i class="fa fa-user text-blue-700 mr-1"></i> <span id="name"></span></span>
      <span class="mr-6 font-bold"><i class="fa fa-id-card mr-1"></i> <span id="regnum"></span></span>
      <span class="font-bold"><i class="fa fa-clock mr-1"></i> <span id="time"></span></span>
    </div>
    <div class="text-xl font-semibold mb-1 text-gray-700" id="score-area"></div>
    <div class="text-gray-500 mb-8" id="score-feedback"></div>
    <div id="results-list"></div>
  </div>

  <script>
    // Load previous answers and exam info
    let examInfo = {}, answers = {};
    try {
      examInfo = JSON.parse(sessionStorage.getItem('cbt_exam_info') || '{}') || {};
      answers = JSON.parse(sessionStorage.getItem('cbt_user_answers') || '{}') || {};
    } catch (e) {
      examInfo = {}; answers = {};
    }

    // Fetch questions from server (original source)
    async function fetchQuestions() {
      const accessCode = localStorage.getItem("exam_access_code");
      if (!accessCode) return { questions: [], subject: "" };
      try {
        const res = await fetch("https://examguide.onrender.com/api/exam-set/by-access?accessCode="+encodeURIComponent(accessCode));
        if(!res.ok) return {questions:[],subject:""};
        const js = await res.json();
        return { questions: js.questions||[], subject: js.examSet?.subject||"" };
      } catch {
        return { questions: [], subject: "" };
      }
    }

    function getTimeString(iso) {
      if (!iso) return "";
      const d = new Date(iso);
      return d.toLocaleString(undefined, {dateStyle:"medium", timeStyle:"short"});
    }

    function getScoreTally(results) {
      let correct = 0;
      results.forEach(r => { if (r.isCorrect) correct++; });
      return [correct, results.length];
    }

    function feedbackRemark(pct) {
      if(pct === 100) return "Excellent! You aced it!";
      if(pct>=80) return "Great work! Almost perfect.";
      if(pct>=60) return "Good. Room for more study.";
      if(pct>=40) return "Keep practicing and revisit the topic.";
      return "Don't give up! Review the material and try again.";
    }

    // --- Normalize LaTeX within HTML strings so MathJax will typeset them ---
    function normalizeQuestionMath(html) {
      if (!html || typeof html !== 'string') return html;

      // Unescape double backslashes that may have been introduced by JSON/string escaping
      let s = html.replace(/\\\\/g, '\\');

      // If the string already contains explicit math delimiters, assume it's fine.
      if (/\\\(|\\\[|\$\$?/.test(s)) return s;

      // Wrap common LaTeX command patterns with inline delimiters.
      const cmdRegex = /\\(?:frac|sqrt|sum|int|lim|left|right|cdot|times|pi|alpha|beta|gamma|theta|log|ln|Delta|delta)(?:\{[^}]*\}|\^[^{\s]+|\_[^{\s]+)*/g;
      s = s.replace(cmdRegex, function(m) { return `\\(${m}\\)`; });

      // Wrap simple superscript/subscript patterns like x^2, x^{2}, x_1, x_{10}
      const expRegex = /([A-Za-z0-9])\^(?:\{[^}]+\}|\d+)/g;
      s = s.replace(expRegex, function(m) { return `\\(${m}\\)`; });

      const subRegex = /([A-Za-z0-9])_(?:\{[^}]+\}|\d+)/g;
      s = s.replace(subRegex, function(m) { return `\\(${m}\\)`; });

      return s;
    }

    // Main render
    async function main() {
      document.getElementById('name').textContent = examInfo.student || "No info";
      document.getElementById('regnum').textContent = examInfo.matric || "";
      document.getElementById('time').textContent = getTimeString(examInfo.timeCompleted);

      const {questions,subject} = await fetchQuestions();
      document.getElementById('subject').textContent = subject || "CBT Report";

      let results = [];
      const resultsList = document.getElementById('results-list');
      resultsList.innerHTML = "";

      for (let i = 0; i < questions.length; i++) {
        const q = questions[i];
        const qid = q._id || q.id || `q${i}`;
        const userAns = answers[qid] || answers[q._id] || answers[q.id] || "";
        const correctAns = q.answer;
        const isCorrect = (userAns === correctAns);
        results.push({ isCorrect });

        // Find option texts (if any) and normalize
        const opt = q.options || [];
        const userOpt = opt.find(o => o.key === userAns);
        const correctOpt = opt.find(o => o.key === correctAns);

        // Normalize question, option texts and explanation so MathJax can render them
        const questionHtml = normalizeQuestionMath(q.question || '');
        const userOptText = userOpt ? normalizeQuestionMath(userOpt.text || '') : '';
        const correctOptText = correctOpt ? normalizeQuestionMath(correctOpt.text || '') : '';
        const explanationHtml = normalizeQuestionMath(q.explanation || '');

        resultsList.innerHTML += `
          <div class="qcard mt-2 ${isCorrect ? "correct" : "incorrect"}">
            <div class="text-base font-bold mb-2 text-gray-800 flex items-center">
              <span class="inline-block w-8 h-8 mr-3 bg-blue-100 text-blue-800 text-center rounded-full font-extrabold">${i+1}</span>
              <span>${questionHtml}</span>
            </div>
            <div class="mb-2">
              <div class="flex flex-wrap items-center gap-3 mb-1">
                <span class="font-semibold text-gray-700">Your Answer: </span>
                <span class="answer-pill answer-user">${userAns ? `${userAns}${userOptText ? `. ${userOptText}` : ""}` : "N/A"}</span>
                ${userAns ?
                  (userAns === correctAns
                    ? `<span class="ml-2 answer-pill answer-correct"><i class="fa fa-check mr-1"></i> Correct</span>`
                    : `<span class="ml-2 answer-pill answer-wrong"><i class="fa fa-times mr-1"></i> Wrong</span>`)
                  : `<span class="ml-2 answer-pill" style="background:#f1f5f9;color:#64748b;"><i class="fa fa-minus mr-1"></i> Not Answered</span>`
                }
              </div>
              <div class="flex flex-wrap items-center gap-3">
                <span class="font-semibold text-gray-700">Correct Answer:</span>
                <span class="answer-pill answer-correct">${correctAns}${correctOptText ? `. ${correctOptText}` : ""}</span>
              </div>
            </div>
            <details class="mt-2 explanation">
              <summary class="font-bold text-blue-900 cursor-pointer">Explanation</summary>
              <div class="pt-2">${explanationHtml ? explanationHtml : "<em>No explanation for this question.</em>"}</div>
            </details>
          </div>
        `;
      }

      // Request MathJax to typeset the newly inserted HTML so LaTeX renders
      // Wait for MathJax if available
      if (window.MathJax && MathJax.typesetPromise) {
        try {
          await MathJax.typesetPromise([resultsList]);
        } catch (err) {
          console.warn("MathJax typeset error:", err && err.message);
        }
      }

      // Score and feedback
      const [correct, total] = getScoreTally(results);
      const percent = total ? Math.round(correct/total*100) : 0;
      document.getElementById('score-area').innerHTML = `
        <span class="text-3xl font-black text-blue-700">${correct} / ${total}</span>
        <span class="text-lg text-gray-700 ml-3">(${percent}%)</span>
      `;
      document.getElementById('score-feedback').textContent = feedbackRemark(percent);
    }

    window.addEventListener('DOMContentLoaded', main);

    // PDF Download button: ensure MathJax rendering is complete before capture
    document.addEventListener('DOMContentLoaded', function() {
      const btn = document.getElementById('download-pdf-btn');
      if (!btn) return;
      btn.onclick = async function() {
        const reportMain = document.getElementById('report-main');
        // Ensure MathJax completed typesetting any SVGs
        if (window.MathJax && MathJax.typesetPromise) {
          try {
            await MathJax.typesetPromise();
            // give browsers a tick to finish layout
            await new Promise(r => setTimeout(r, 50));
          } catch (err) {
            console.warn("MathJax typeset before PDF error:", err && err.message);
          }
        }

        // Temporarily set a white background for better PDF result
        const prevBg = reportMain.style.background;
        reportMain.style.background = "#fff";

        // Use html2canvas to rasterize the node
        const canvas = await html2canvas(reportMain, { scale: 2, useCORS: true, backgroundColor: "#fff" });
        reportMain.style.background = prevBg;
        const imgData = canvas.toDataURL("image/png");

        // Create PDF
        const pdf = new jspdf.jsPDF({
          orientation: 'portrait',
          unit: 'pt',
          format: 'a4'
        });
        const pageWidth = pdf.internal.pageSize.getWidth();
        const pageHeight = pdf.internal.pageSize.getHeight();
        const margin = 24;
        const imgWidth = pageWidth - margin * 2;
        const imgHeight = canvas.height * (imgWidth / canvas.width);

        if (imgHeight < pageHeight - margin*2) {
          pdf.addImage(imgData, 'PNG', margin, margin, imgWidth, imgHeight, '', 'FAST');
        } else {
          let renderedHeight = 0;
          while (renderedHeight < imgHeight) {
            pdf.addImage(
              imgData,
              'PNG',
              margin,
              margin - renderedHeight,
              imgWidth,
              imgHeight,
              '',
              'FAST'
            );
            renderedHeight += pageHeight - margin*2;
            if (renderedHeight < imgHeight) pdf.addPage();
          }
        }
        pdf.save("exam-report.pdf");
      };
    });
  </script>
</body>
</html>
